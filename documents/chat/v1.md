## Banddy 채팅 가이드 v1

본 문서는 Banddy 클라이언트에서 채팅 기능을 구현/연동하기 위한 v1 문서입니다. WebSocket(STOMP) + SockJS, REST API(OAS 3.0) 매핑, 사용 시나리오(추가 사례 포함), 트러블슈팅을 포함합니다.

### 대상/범위

- 대상: 프론트엔드(React+Vite) 개발자, 서버와의 연동을 담당하는 개발자
- 범위: 클라이언트 관점에서의 경로/메시지/연결/구독/전송/에러/테스트 절차

### 아키텍처 요약

- 실시간: WebSocket 위 STOMP 사용, SockJS 폴백
- pub/sub:
  - 그룹 채팅: topic 브로드캐스트(`/topic/room/{roomId}`)
  - 개인 채팅: queue 유니캐스트(`/user/queue/room/{roomId}`)
- 안읽음: `/user/queue/unread` 구독으로 실시간 카운팅
- 읽음: 참가자별 마지막 읽은 시각 vs 메시지 타임스탬프 비교

---

### 목적지(DESTINATION) 표준

- 구독(SUBSCRIBE)
  - 그룹: `/topic/room/{roomId}`
  - 개인: `/user/queue/room/{roomId}`
  - 안읽음: `/user/queue/unread`
- 전송(SEND)
  - 메시지: `/app/chat/sendMessage/{roomId}`

### STOMP CONNECT 헤더

```text
accept-version: 1.1,1.0
heart-beat: 10000,10000
Authorization: <ACCESS_TOKEN>
```

- 주의: WebSocket Authorization은 Bearer 접두어 없이 토큰 문자열 자체를 보냅니다.
- REST 요청은 인터셉터에서 `Bearer <token>` 자동 부착됩니다.

---

### 메시지 스키마

- 전송 바디

```json
{
  "content": "안녕하세요!",
  "roomId": 42,
  "roomType": "GROUP", // PRIVATE | GROUP | BAND
  "receiverId": 23 // PRIVATE일 때 필수
}
```

- 수신: 정상 메시지(MESSAGE)

```json
{
  "type": "MESSAGE",
  "data": {
    "messageId": 184,
    "senderId": 23,
    "senderName": "채팅테스트2",
    "content": "안녕하세요!",
    "roomId": 42,
    "timestamp": "2025-08-08T04:09:17.77013405"
  }
}
```

- 수신: 안읽음 알림(UNREAD_MESSAGE)

```json
{
  "type": "UNREAD_MESSAGE",
  "data": {
    "senderId": 16,
    "roomId": 42,
    "content": "안녕하세요!",
    "timestamp": "2025-08-08T03:49:07.522807813"
  }
}
```

---

### REST API 매핑(OAS)

- 목록: GET `/api/chat/rooms` → `getChatRooms()`
- 그룹 생성: POST `/api/chat/rooms`(multipart) → `createGroupChat()`
- 그룹 수정: PATCH `/api/chat/rooms`(multipart) → `updateGroupChat()`
- 참여: POST `/api/chat/rooms/{roomId}/members/join` → `joinChatRoom()`
- 퇴장: POST `/api/chat/rooms/{roomId}/members/exit` → `leaveChatRoom()`
- 개인 생성/입장: POST `/api/chat/rooms/friends` → `createDirectChat()`
- 핀/해제: PATCH `/api/chat/rooms/pin|unpin` → `pinChatRoom()`, `unpinChatRoom()`
- 방 정보: GET `/api/chat/rooms/{roomId}` → `getChatRoomMembers()`(참가자 lastReadAt 포함)
- 메시지: GET `/api/chat/rooms/{roomId}/messages?cursor&limit` → `getChatMessages()`

---

### 클라이언트 소스 매핑

- `src/constants/index.ts`
  - `WEBSOCKET.SUBSCRIBE_GROUP(roomId)` → `/topic/room/{roomId}`
  - `WEBSOCKET.SUBSCRIBE_PRIVATE(roomId)` → `/user/queue/room/{roomId}`
  - `WEBSOCKET.SUBSCRIBE_UNREAD` → `/user/queue/unread`
  - `WEBSOCKET.SEND_MESSAGE(roomId)` → `/app/chat/sendMessage/{roomId}`
  - `CHAT.*` REST 엔드포인트 모음
- `src/types/chat.ts`
  - `WebSocketSendMessage`에 `roomType`, `receiverId` 포함
- `src/services/WebSocketService.ts`
  - `subscribeToGroupRoom`, `subscribeToPrivateRoom`, `subscribeToUnread`
  - `sendMessage(roomId, content, roomType, receiverId?)`
  - STOMP 헤더 설정(Authorization/heart-beat)
- `src/pages/chat/hooks/useWebSocket.ts`
  - `joinRoom(roomId, roomType)` 타입 분기 구독
  - `sendMessage(content, roomType, receiverId?)`
  - 연결 시 `/user/queue/unread` 자동 구독(스토어 연동은 후속)
- `src/pages/chat/hooks/useChat.ts`
  - `enterChatRoom(roomId, roomType)` → REST join → WS 구독 → 메시지 로드
  - `sendMessage(text, roomType, receiverId?)`
  - 무한 스크롤: `getChatMessages()`
- `src/store/chatApi.ts`
  - 그룹 생성/수정, 참여/퇴장, 친구 채팅, 핀/해제

---

## 추가 사례(Use cases)

### A) 그룹 채팅 플로우

```ts
const { enterChatRoom, sendMessage } = useChat();
useEffect(() => {
  enterChatRoom("42", "GROUP");
}, []);
sendMessage("안녕하세요!", "GROUP");
```

### B) 개인 채팅 플로우(방 자동 생성/입장)

```ts
// 1) REST로 방 생성/입장
const { roomId } = await createDirectChat({ memberId: 23 });

// 2) WS 구독 + 메시지 전송
const { enterChatRoom, sendMessage } = useChat();
await enterChatRoom(String(roomId), "PRIVATE");
sendMessage("안녕하세요!", "PRIVATE", 23);
```

### C) 안읽은 메시지 카운트 연동(스토어 예시)

```ts
// pseudo: chatStore
unreadCounts: Record<number, number> = {} // roomId -> count

handleUnread(payload) {
  const roomId = payload.data.roomId
  unreadCounts[roomId] = (unreadCounts[roomId] || 0) + 1
}

resetUnread(roomId: number) {
  unreadCounts[roomId] = 0
}

// 연결 성공 시
webSocketService.subscribeToUnread(handleUnread)
```

### D) 읽음 처리 계산(참가자별 마지막 읽은 시각)

```ts
// 입장 시 REST로 participantInfos 로드
// participantReadTimes[roomId][memberId] = lastReadAt

calculateUnreadForMessage(messageTs: string, roomId: number) {
  const map = participantReadTimes[roomId] || {}
  return Object.values(map).filter((readTs) => new Date(readTs) < new Date(messageTs)).length
}

// (옵션) 읽음 마크 전송 엔드포인트 확정 시
sendReadMark(roomId: number, ts: string)
```

### E) 재연결/자동 재구독

```ts
// WebSocketService
reconnectDelay, onWebSocketClose -> handleReconnect()

// useWebSocket
reconnect() → disconnect(); setTimeout(connect); 이전 roomId 재구독
```

### F) 채팅방 핀/핀 해제

```ts
await pinChatRoom({ chatId: 42 });
await unpinChatRoom({ chatId: 42 });
```

### G) 디버그 툴 세팅

```text
URL: https://<host>/ws  (SockJS는 http/https URL)
Headers:
  accept-version: 1.1,1.0
  heart-beat: 10000,10000
  Authorization: <ACCESS_TOKEN>

SUBSCRIBE: /topic/room/42  또는  /user/queue/room/43  또는  /user/queue/unread
SEND: /app/chat/sendMessage/42 + JSON Body
```

---

## 트러블슈팅

- 연결 실패: 토큰/헤더 확인, CORS, SockJS 경로(`/ws`) 확인
- 구독 무반응: 목적지(topic/queue) 재확인, 구독 해제 누락 여부 체크
- 개인 전송 실패: `roomType: "PRIVATE"`, `receiverId` 필수 확인
- 브로드캐스트 중복 수신: topic은 내 메시지도 수신(의도된 동작)

## 환경 변수

- `VITE_API_BASE_URL=https://banddy.site` (예시)

## 참고 파일 경로

- `src/constants/index.ts`
- `src/types/chat.ts`
- `src/services/WebSocketService.ts`
- `src/pages/chat/hooks/useWebSocket.ts`
- `src/pages/chat/hooks/useChat.ts`
- `src/store/chatApi.ts`

## 버전 정책

- v1: 채팅 핵심(그룹/개인, 안읽음, 무한 스크롤, 핀/해제) 구현 가이드 + 추가 사례 수록
- 향후 v2: 읽음 마크 단일 WS 엔드포인트 통합, 파일/오디오 전송, 배달보장/오프라인 큐 반영 예정
